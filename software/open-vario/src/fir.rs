pub struct FIR<const N: usize> {
    coeffs: [f32; N],
    values: [f32; N],
    last_index: usize,
}

impl<const N: usize> FIR<N> {
    pub const fn new(coeffs: [f32; N]) -> Self {
        FIR {
            coeffs: coeffs,
            values: [0.0f32; N],
            last_index: 0,
        }
    }
    pub fn feed(&mut self, value: f32) {
        self.values[self.last_index] = value;
        self.last_index = (self.last_index + 1) % N;
    }
    pub fn output(&self) -> f32 {
        let mut output: f32 = 0.;
        for i in 0..N {
            let shifted_index = (self.last_index + i) % N;
            output += self.coeffs[i] * self.values[shifted_index]
        }
        output
    }
}

pub const FIR93: FIR<93> = FIR::new([
    0.000000000000000000,
    0.000000000000000000,
    0.000007188274115481,
    0.000026999392415735,
    0.000049699512645601,
    0.000049863203532925,
    0.000000000000000000,
    -0.000106466630123868,
    -0.000235784361628246,
    -0.000313423411736154,
    -0.000251660491775780,
    0.000000000000000000,
    0.000403178328101412,
    0.000808959582588773,
    0.000992137799152341,
    0.000744815418518378,
    -0.000000000000000001,
    -0.001072273934694242,
    -0.002059763470923100,
    -0.002430325033226228,
    -0.001762349297820786,
    0.000000000000000002,
    0.002390452110110751,
    0.004475318846985163,
    0.005158538261110197,
    0.003662355995274633,
    -0.000000000000000003,
    -0.004791312805438043,
    -0.008836419633830974,
    -0.010054535287361244,
    -0.007062019894287973,
    0.000000000000000005,
    0.009108666787451508,
    0.016750199379556279,
    0.019068143596055322,
    0.013452460567012516,
    -0.000000000000000006,
    -0.017780693242571512,
    -0.033453572438736034,
    -0.039359812124647071,
    -0.029101364265679112,
    0.000000000000000007,
    0.045364163923913244,
    0.099190334251021056,
    0.150217079433425715,
    0.186747434189619838,
    0.200007574943747768,
    0.186747434189619838,
    0.150217079433425743,
    0.099190334251021070,
    0.045364163923913244,
    0.000000000000000007,
    -0.029101364265679108,
    -0.039359812124647078,
    -0.033453572438736048,
    -0.017780693242571508,
    -0.000000000000000006,
    0.013452460567012516,
    0.019068143596055322,
    0.016750199379556286,
    0.009108666787451508,
    0.000000000000000005,
    -0.007062019894287979,
    -0.010054535287361239,
    -0.008836419633830977,
    -0.004791312805438043,
    -0.000000000000000003,
    0.003662355995274636,
    0.005158538261110193,
    0.004475318846985165,
    0.002390452110110752,
    0.000000000000000002,
    -0.001762349297820787,
    -0.002430325033226230,
    -0.002059763470923101,
    -0.001072273934694242,
    -0.000000000000000001,
    0.000744815418518378,
    0.000992137799152341,
    0.000808959582588773,
    0.000403178328101412,
    0.000000000000000000,
    -0.000251660491775781,
    -0.000313423411736154,
    -0.000235784361628246,
    -0.000106466630123867,
    0.000000000000000000,
    0.000049863203532925,
    0.000049699512645602,
    0.000026999392415735,
    0.000007188274115481,
    0.000000000000000000,
    0.000000000000000000,
]);

macro_rules! moving_average {
    ($n: expr) => {{
        use crate::fir::FIR;
        const N: usize = $n as usize;
        let coeffs: [f32; N] = [1.0f32 / (N as f32); N];
        FIR::<N>::new(coeffs)
    }};
}
pub(crate) use moving_average;
